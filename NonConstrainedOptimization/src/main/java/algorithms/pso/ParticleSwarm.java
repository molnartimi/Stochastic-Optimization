package algorithms.pso;import java.util.ArrayList;import java.util.List;import java.util.Random;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import algorithms.Optimizer;import algorithms.OptimizerResult;import algorithms.ToleranceExceededException;import hu.bme.mit.inf.petridotnet.spdn.SpdnException;import model.Model;public class ParticleSwarm extends Optimizer<PSOHyperParam> {	public static final String ID = "PSOP";	protected static final Logger logger = LoggerFactory.getLogger(ParticleSwarm.class);			protected List<Double> bestPoint = null;	protected double bestValue;	protected double tolerance;		public ParticleSwarm(Model model) {		super(model);	}	protected class Particle {		private List<Double> x, v, PBestPoint;		private double PBestValue;		public Particle(List<Double> pos, List<Double> vel) {			x = pos;			PBestPoint = copyArray(x);			v = vel;			PBestValue = modelChecker.calcObjective(PBestPoint);		}		public List<Double> getLocalBestPoint() {			return PBestPoint;		}		public double getLocalBestValue() {			return PBestValue;		}		public List<Double> getV() {			return v;		}		public List<Double> getX() {			return x;		}		public void step(List<Double> newX, List<Double> newV) throws ToleranceExceededException {			model.cutParamsOnBorder(newX);			x = copyArray(newX);			v = copyArray(newV);			double value = modelChecker.calcObjective(x);			if (value < PBestValue) {				updateBest(x, value);			}		}	}	public OptimizerResult optimize(PSOHyperParam params) {		logger.info("Start to optimize " + model.id);		long startTime = System.nanoTime();		tolerance = params.tolerance;				logger.info("Initializing swarm");		try {			List<Particle> swarm = initSwarm(params.swarmSize);					logger.info("Starting to step particles");			for (int i = 0; i < params.maxIter; i++) {				for (int j = 0; j < params.swarmSize; j++) {					Particle p = swarm.get(j);					stepParticle(p, params.omega, params.fiParticle, params.fiGlobal);					if (bestValue > p.getLocalBestValue()) {						updateBest(p.getLocalBestPoint(), p.getLocalBestValue());					}				}			}		} catch (ToleranceExceededException e) {			logger.info("Tolerance border exceeded, stop optimization");		}		OptimizerResult result = new OptimizerResult(bestValue, bestPoint, ID, params.getHyperParams(), model);		result.setTime(System.nanoTime() - startTime);		return result;	}		protected void stepParticle(Particle p, double omega, double fiParticle, double fiGlobal) throws ToleranceExceededException {		Random r = new Random();				List<Double> x = copyArray(p.getX());		List<Double> v = copyArray(p.getV());		List<Double> best = copyArray(p.getLocalBestPoint());		for (int d = 0; d < model.parameterSize(); d++) {			v.set(d, omega * v.get(d) + fiParticle * r.nextDouble() * (best.get(d) - x.get(d))					+ fiGlobal * r.nextDouble() * (bestPoint.get(d) - x.get(d)));			x.set(d, x.get(d) + v.get(d));		}		p.step(x, v);	}		protected List<Particle> initSwarm(int swarmSize) throws ToleranceExceededException {		List<Particle> swarm = new ArrayList<>();		List<List<Double>> randoms = model.latinHypercubeParamValues(swarmSize);		for (List<Double> paramValueList: randoms) {			Particle p = new Particle((List<Double>) paramValueList, model.randomVelocity());			swarm.add(p);			if (bestPoint == null || p.getLocalBestValue() < bestValue) {				updateBest(paramValueList, p.getLocalBestValue());			}		}		return swarm;	}		private void updateBest(List<Double> newBestPoint, double newBestValue) throws ToleranceExceededException {		logger.info("New best value " + newBestValue + " in point " + newBestPoint.toString());		bestPoint = copyArray(newBestPoint);		bestValue = newBestValue;		if (bestValue < tolerance) throw new ToleranceExceededException();	}	}